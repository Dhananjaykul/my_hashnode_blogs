---
title: "Docker for DevOps Engineers(Docker-Volume & Docker Network)"
seoTitle: "Docker Volume & Docker Network"
seoDescription: "Know about Docker volumes,Network and use Docker volumes and named volumes to share files and directories between multiple containers."
datePublished: Wed Apr 19 2023 12:01:25 GMT+0000 (Coordinated Universal Time)
cuid: clgnn7w94000309mi1alf9n6u
slug: docker-for-devops-engineersdocker-volume-docker-network
cover: https://cdn.hashnode.com/res/hashnode/image/upload/v1682513833644/7a0ff9f2-0015-4cd2-91f7-adecfc414dd1.webp
tags: docker, devops, docker-compose, 90daysofdevops, trainwithshubham

---

Docker is a popular containerization technology that has revolutionized the way developers build and deploy applications. Docker volumes and Docker networks are two key concepts in Docker that help to enhance the functionality and flexibility of Docker containers. In this blog, we will explore what Docker volumes and Docker networks are and how they work.

What are Docker Volumes? Docker volumes are a mechanism for persisting data generated by Docker containers. They allow data to be stored outside of the container's file system, making it easy to manage and share data between containers. Docker volumes are created using the 'docker volume' command, which creates a new volume or attaches to an existing volume. Docker volumes can be mounted as a directory within a container, allowing data to be written to and read from the volume as if it were part of the container's file system.

Advantages of Docker Volumes:

1. Data persistence: Docker volumes ensure that data generated by a container is not lost when the container is stopped or deleted.
    
2. Easy data sharing: Docker volumes can be easily shared between containers, allowing multiple containers to access the same data.
    
3. Performance: Docker volumes are optimized for performance, ensuring that data is stored and retrieved quickly.
    

What are Docker Networks? Docker networks are a way to connect Docker containers, allowing them to communicate with each other. A Docker network can be created using the 'docker network' command, which creates a new network or attaches to an existing network. Containers can then be attached to the network using the 'docker run' command with the '--network' flag.

Advantages of Docker Networks:

1. Isolation: Docker networks provide a way to isolate containers from each other, ensuring that they can only communicate with each other through the network.
    
2. Security: Docker networks can be secured using firewalls and other security measures to prevent unauthorized access.
    
3. Scalability: Docker networks make it easy to scale applications by allowing new containers to be added to the network as needed.
    

Docker volumes and Docker networks are important concepts in Docker that help to enhance the functionality and flexibility of Docker containers. Docker volumes provide a way to persist data generated by containers, while Docker networks provide a way to connect containers and enable communication between them. By understanding these concepts, developers can create more efficient and scalable applications using Docker.

### Task 1. Create a multi-container docker-compose file which will bring \*UP\* and bring \*DOWN\* containers in a single shot

Here are the steps to use this `docker-compose.yml` file for a Django TODO application with a MySQL database image version 5.7:

1. Create a new directory for your project and navigate into it.
    

```bash
mkdir django-todo-cicd
cd django-todo-cicd
```

1. Create a new file named `docker-compose.yml`.
    

```bash
touch docker-compose.yml
```

1. Copy and paste the following content to the `docker-compose.yml` file:
    
    ![](https://cdn.hashnode.com/res/hashnode/image/upload/v1681898996148/8d961eae-8d10-4963-b7cd-7bc3b77e56ba.png align="center")
    

1. The `docker-compose.yml` file defines two services, `django_todo_app` and `mysql_db`, and two named volumes `django_todo_volumes` and `db_data`.
    
2. The `django_todo_app` service uses the `.` build context to build the Django application image, maps port `8000` on the host to port `8000` in the container, and mounts the `django_todo_volumes` volume to persist the Django code.
    
3. The `environment` options set some environment variables for the Django application to connect with the MySQL database.
    
4. The `mysql_db` service uses the `mysql:5.7` image, maps port `3306` on the host to port `3306` in the container, sets the `MYSQL_ROOT_PASSWORD` environment variable, and mounts the `db_data` volume to persist the database data.
    
5. Save the `docker-compose.yml` file.
    
6. To start the application, run the following command from the project directory:
    

```bash
docker-compose up -d
```

1. ![](https://cdn.hashnode.com/res/hashnode/image/upload/v1681899298076/a9cfb979-bff9-426a-9579-13e93a399b0f.png align="center")
    
2. To view the status of all containers, run the following command:
    

```bash
docker-compose ps
```

![](https://cdn.hashnode.com/res/hashnode/image/upload/v1681899411266/cbb26151-2be8-42fe-9096-fc8d83df40e9.png align="center")

1. To view the logs of a specific service, run the following command:
    
    ```bash
    docker-compose logs <service_name>
    ```
    
    ![](https://cdn.hashnode.com/res/hashnode/image/upload/v1681899634859/4c4f2cd8-8341-41f2-a931-c9ccd12cd203.png align="center")
    
2. To stop and remove all containers, networks, and volumes associated with the application, run the following command:
    

```bash
docker-compose down
```

Oops!!!!!!Got an error while running this 13th step to stop the container here's the error:

![](https://cdn.hashnode.com/res/hashnode/image/upload/v1681900094459/2689ec7d-3742-4475-a866-807d60a1e0b4.png align="center")

The errors you are facing indicate that the Docker containers for your django-todo-cicd application is not able to be stopped. The error message "`permission denied`" suggests that the user running the command does not have the required permissions to execute the Docker commands.

To solve this issue, you can try the following steps:

1. Check if there are any processes running inside the containers. If there are processes running, stop them before running the `docker-compose down` command. To get a list of running containers, run the command:
    

```bash
sudo docker ps
```

![](https://cdn.hashnode.com/res/hashnode/image/upload/v1681900288635/bf6f8030-dc3a-4efc-b04d-0ea27ffde1d3.png align="center")

1. Ensure that the user running the command has the necessary permissions to execute Docker commands. You can add the user to the `docker` group using the following command:
    

```bash
sudo usermod -aG docker ${USER}
```

1. Logout and then log back in to apply the group changes.
    
2. Try running the `docker-compose down` command again.
    

If the above steps do not work, you can try a more forceful approach to stop by running the following commands:

```bash
sudo docker-compose down -v
```

![](https://cdn.hashnode.com/res/hashnode/image/upload/v1681900654293/1d8e2558-b47c-48e4-89c1-32f7968d071f.png align="center")

### **Task 2. Learn how to use Docker Volumes and Named Volumes to share files and directories between multiple containers.**

### **\- Create two or more containers that read and write data to the same volume using the** `docker run --mount` **command.**

### **\- Verify that the data is the same in all containers by using the docker exec command to run commands inside each container.**

### **\- Use the docker volume ls command to list all volumes and docker volume rm command to remove the volume when you're done.**

here are the steps to use Docker volumes and named volumes to share files and directories between multiple containers:

1. Create a new directory for your project and navigate into it.
    
    ![](https://cdn.hashnode.com/res/hashnode/image/upload/v1681902974999/903b2b2b-c9aa-417a-8561-8624dc033724.png align="center")
    
2. Create a new file named `index.html` in the project directory.
    
    ![](https://cdn.hashnode.com/res/hashnode/image/upload/v1681903068261/b97a22d7-c532-49a2-9f4f-a855e27f9c29.png align="center")
    
3. Run the following command to create a new container that reads and writes data to a volume named `my-volume`.
    

```bash
docker run --name container-1 --mount source=my-volume,target=/app -d nginx
```

![](https://cdn.hashnode.com/res/hashnode/image/upload/v1681903175646/8a01ba7e-34bd-4f8f-a348-fb57143f5f97.png align="center")

This command creates a new container named `container-1`, mounts the `my-volume` volume to the `/app` directory inside the container, and starts an Nginx web server in detached mode.

1. Run the following command to verify that the container is running.
    

```bash
docker ps
```

![](https://cdn.hashnode.com/res/hashnode/image/upload/v1681903810519/c08585d8-df96-4694-8c5b-b648fe527e3f.png align="center")

1. Run the following command to verify that the `index.html` file exists in the container's volume.
    

```bash
docker exec container-1 ls /app
```

![](https://cdn.hashnode.com/res/hashnode/image/upload/v1681904515778/1514463d-8b24-4c1c-b83a-b61315fb054f.png align="center")

1. Run the following command to read the contents of the `index.html` file from inside the container.
    

```bash
docker exec container-1 cat /app/index.html
```

This command should output "Hello, World!".

![](https://cdn.hashnode.com/res/hashnode/image/upload/v1681904579607/39bed4c2-8e87-4e7c-953b-db7259ac1a14.png align="center")

1. Run the following command to create a second container that also reads and writes data to the `my-volume` volume.
    

```bash
docker run --name container-2 --mount source=my-volume,target=/app -d nginx
```

This command creates a new container named `container-2`, mounts the `my-volume` volume to the `/app` directory inside the container, and starts an Nginx web server in detached mode.

1. Run the following command to verify that the second container is running.
    

```bash
docker ps
```

1. Run the following command to verify that the `index.html` file exists in the second container's volume.
    

```bash
docker exec container-2 ls /app
```

1. Run the following command to read the contents of the `index.html` file from inside the second container.
    

```bash
docker exec container-2 cat /app/index.html
```

This command should also output "Hello, World!".

![](https://cdn.hashnode.com/res/hashnode/image/upload/v1681904794276/2e3f3e1b-076c-4248-84c6-c5136925896c.png align="center")

1. Edit the `index.html` file on one of the containers to change the contents of the file.
    

```bash
docker exec container-1 sh -c "echo 'Hello, Docker!' > /app/index.html"
```

1. Run the following command to read the contents of the `index.html` file from inside the first container.
    

```bash
docker exec container-1 cat /app/index.html
```

This command should output "Hello, Docker!".

![](https://cdn.hashnode.com/res/hashnode/image/upload/v1681904905350/b5a02ebe-343e-4e65-8287-0e9641ac70b4.png align="center")

1. Run the following command to read the contents of the `index.html` file from inside the second container.
    

```bash
docker exec container-2 cat /app/index.html
```

This command should also output "Hello, Docker!".

![](https://cdn.hashnode.com/res/hashnode/image/upload/v1681904989005/1a1717c0-118f-4ba3-b03a-87b24a44cb28.png align="center")

1. Run the following command to list all volumes created in the system.
    

```bash
docker volume ls
```

You should see the `my-volume` volume in the list.

![](https://cdn.hashnode.com/res/hashnode/image/upload/v1681905046560/60f423dc-18db-4da4-8ac4-91c622c4608f.png align="center")

1. To remove the `my-volume` volume, run the following command.
    

```bash
docker volume rm my-volume
```

ðŸ˜’ðŸ˜’ðŸ˜’Again an Error

![](https://cdn.hashnode.com/res/hashnode/image/upload/v1681905155447/dfbd6668-16c1-4d2d-833e-53e299c6df6a.png align="center")

The error message indicates that the volume "my-volume" is currently in use by one or more containers. This means that you cannot remove the volume until all containers that are using it have been stopped and removed.

To resolve this error, you'll need to follow these steps:

1. Use the `docker ps` command to list all currently running containers.
    
2. Look for any containers that are using the "my-volume" volume.
    
3. Stop these containers using the `docker stop` command, followed by the container ID or name.
    
4. Remove the containers using the `docker rm` command, followed by the container ID or name.
    
5. Finally, you can use the `docker volume rm` command again to remove the "my-volume" volume.
    

Here's an example of how you could do this:

![](https://cdn.hashnode.com/res/hashnode/image/upload/v1681905374405/864efa02-9b7c-4ecb-bd75-3045f13796d6.png align="center")

Note that you'll need to replace "container-1" and "container-2" with the actual names or IDs of the containers that are using the "my-volume" volume.

I hope this helps!

  
That's it! You have successfully used Docker volumes and named volumes to share files and directories between multiple containers.